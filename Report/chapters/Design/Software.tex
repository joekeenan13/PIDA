\section{Software Design}

\paragraph{}
The majority of the scope of this project was related to the software and firmware design and implementation.
This section details the design of the software, it's implementation, as well as issues encountered and the ways in which they were addressed or what needs to happen to address the issue.

\subsection{High Level Design and Implementation}

\paragraph{}
The software for this DAQ is designed and implemented to be run in a pseudo-parallel manner.
This means that there are several different tasks that are running sequentially, with each task running small chunks or sub-tasks during each cycle.
Each task is then designed as a state machine to segment itself into these smaller sub-tasks.
In order for each of these tasks to communicate with each other, there is one group of data that each task can reference.
Since this is a sequential action still, conflicts will not occur and ther does not need to be any extra protections for accessing the same data or variable at the same time.

\paragraph{}
The DAQ runs four main tasks that are continuously cycled through:
\begin{itemize}
	\item[(1)] Storage
	\item[(2)] Communication
	\item[(3)] Radio Communication
	\item[(4)] Sensors
	\item[(5)] Health Monitoring
\end{itemize}
The storage task is responsible for the actual logging of data.
The communication task is the task responsible for reading data off the CAN bus.
The radio communication task is responsible for medium-long range telemetry.
The sensors task is responsible for the reading of all on-board sensors.
The health monitoring task is responsible for updating any LED indicators for the health of the system.
Together, these five main tasks handle the running of all parts of the system.
As can be seen in \cref{fig:SoftwareTasks}, these tasks all run sequentially before looping back to the start.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\linewidth]{SoftwareTasks.png}
	\caption{Software tasks loop diagram}
	\label{fig:SoftwareTasks}
\end{figure}

\paragraph{}
Object-oriented programming (OOP) is utilized significantly for this design.
Every task and sensor is a class that have individiual constructors depending on the needs of the task.
Additionally, each task gets its own enum classes to define the various states for each state machine.
There are two parent classes that are utilized by everything.
For different tasks, there is an abstract task class that forces an implementation for a function that runs the task and requires the intercommunication data to be passed in.
For sensors, there is an abstract sensor class that forces an implementation for two functions, an initialization function and an update function.
Additionally, this class implements a read function that returns the current sensor value.

\paragraph{}
Since this project is based on the Arduino platform, several of the basic tasks for interacting with the hardware are handled by the platform.
This includes things such as setting the mode of a pin, reading and writing from data registers, configuring UART, SPI, and SDIO interfaces, and configuring the interrupt vector table.
Even with the configuration of these periphreals being handled by Arduino, they still need to be configured with the proper settings to be used.
Despite all falling under the Arduino umbrella, each platform is maintained independently of each other.
The people maintaining the Arduino platform for Teensy and the people maintaining the Arduino platform for STM do not communicate with each other, and as a result there are some implementation differences that exist between different hardware platforms using Arduino.

\paragraph{}
Additionally, not every family of microcontrollers from STM receives the same support or even the sample supported functions from the Arduino framework.
One specific issue that arose was a versioning issue for STM32duino.
In versions 18.0.0 onwards, the memory sizes of the H7 family of STM microcontrollers was updated incorrectly, causing code to not run and the debugger to be unusable.
This issue was resolved by reverting the version of STM32duino back to 17.6.0.
Other issues that arose that were not issus on the Teensy platform were the signedness of pins on the STM32, multiple timers on the same timer channels, timer registers having different sizes, and the same interrupt being tied to multiple pins.
One of the largest benefits of this change was having access to the debugger.
Without access to a deebugger, many of these issues would not have been solved or would have taken weeks or longer to debug.

\subsection{Storage Task}

\paragraph{}
The first and foremost task that the DAQ runs is the storage task.
This task is responsible for managing the SD interface as well as managing the filesystem.
This includes things like initializing the communication interface with the SD card, setting up the filesystem, and writing data to the SD card.

\paragraph{}
As with all tasks, this was implemented via a state machine.
A diagram for this state machine can be seen in \cref{fig:StorageDiagram}.
This machine consists of seven states, with each state handling a single part of the task.
These state are:
\begin{itemize}
	\item Initialize
	\item Wait to Open
	\item Open
	\item Wait to Write
	\item Write
	\item Close
	\item Error
\end{itemize}
In this state machine, there are two types of states.
These are action states and waiting states.
The action states are all capable of entering the error state if their action fails unexpectandtly.
The waiting states are incapable of entering the error state, since their sole purpose is to wait for certain conditions needed for their corresponding action state.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\linewidth]{SDStateMachine.png}
	\caption{Storage State Diagram}
	\label{fig:StorageDiagram}
\end{figure}

\paragraph{}
The Initialize state is responsible for creating the SD instance.
This includes configuring the SDIO communication interface that physically connects the SD card to the microcontroller as well as mounting the FatFS filesystem that is used by the SD card.
The creation of the SD and File objects relies on STM32SD library.
This library provides the functions for initializing the SD interface and for mounting the filesystem.
One major issue is present in this library that needed to be fixed.
The library expects the FatFS implementation to have a function f\_unmount, which can be used to unmount the filesystem.
This function is not present in the FatFS implementation provided by STM32duino.
To resolve this issue, the function call can be replaced with a f\_mount function call with the approriate arguments, or a wrapper function f\_unmount can be created that calls f\_mount with the approriate arguments.
The former was used in this project.
If the returns of both the SD initialization and the FatFS initialization are success codes, the next state is Wait to Open.
If any other codes are returned, the next state is the Error state.
This is outlined in the decision tree in INSERT FIGURE.

\paragraph{}
The wait to Open state is a waiting state that holds the storage task until the logging flag is high.
If the logging flag goes high, the next state is Open.
The task can be held in this state indefinately if the logging flag stays low.
This can occur if the logging switch on the dashboard is disabled or removed.

\paragraph{}
The Open state is responsible for the creation of files.
Once the task enters this state, it searches for the next available file name and attempts to create the file.
The file is created and opened properly if the return of the open function, which is a wrapper around the FatFS f\_open function, returns a non-null value.
This state will attempt to open a file three times before deciding it is unable to.
This is outlined in INSERT FIGURE.
If the file is opened properly, the next state is the Wait to Write state.
If the state is unable to open a file, the next state is the Error state.

\paragraph{}
The Wait to Write state is another waiting state that holds the storage task until new data is received.
Once a new piece of data is received from the CAN bus or from reading the onboard sensors, this state transitions to the Write state.
If there are no nodes on the CAN network or a CAN error and all the onboard sensors are disabled, the storage task can be held indefinately in this state.
It is determined that a piece of data is new by checking a boolean value for each data segment.
These booleans are set to true in the communication task or the sensors task.

\paragraph{}
The Write state is responsible for actually writing the most recent data to the SD card.
Once the task enters this state, it iterates through all possible pieces of data to see if they have been updated.
If a piece of data has been updated, a data packet is created with the data id, the data, and then a checksum to improve resiliency.
This packet is then written to the SD write buffer.
Once all updated messages are written to the SD write buffer, the buffer is then flushed to the SD card.
This is done on each iteration as opposed to waiting for the buffer to fill up to reduce the blocking when writing to the disk to reduce the potential risk of missing data updates.
This is outlined in INSERT FIGURE.
If the writes and flush are completed sucessfully and logging is true, the next state is Wait to Write.
If the writes an flush are completed suggessfully and logging is false, the next state is Close.
If the writes or flush fail, the next state is Error.
Once the writes are complete, the booleans that are true for a data segment are reset to false.

\paragraph{}
The final normal state is the Close state.
This state is responsible for safely closing the current open file.
If the file fails to close properly, the next state is the Error state.
If the file closes properly, the next state is the Wait to Open state.

\subsection{Communication Task}

\paragraph{}
The next task is the communication task.
This task is responsible for configuring and managing communication on the CAN bus.
In order to do this, the ACANFD\_STM32 library was modified to support the operations needed to configure the CAN controller into CANFD mode and to read and write from the bus.
One requirement of this library is that the CAN IRQ handler functions need to be defined by the user.
These functions are defined in the main file and must be named properly to use the proper CAN controller, such as adding a 1 or 2 to distinguish between CAN1 and CAN2 hardware.

\paragraph{}
The state machine for the communication task contains four states.
These states are:
\begin{itemize}
	\item Initialize
	\item Wait for Message
	\item Process Message
	\item Error
\end{itemize}
As can be seen in \cref{fig:CommsDiagram}, the two main states that will be looped between are the Wait for Message and Process Message states that handle reading and processing messages.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\linewidth]{CommsStateMachine.png}
	\caption{Communication State Diagram}
	\label{fig:CommsDiagram}
\end{figure}

\paragraph{}
The Initialize state is responsible for configuring the settings and initializing the CAN controller into CAN FD mode.
In order to configure the hardware into CAN FD mode, the pins that connect from the internal CAN controller to the external CAN transceiver need to be set to their alternate functions and the bits in the configuration register need to be set to Normal FD mode.
Additionally, the desired arbitration clock rate and data clock rate need to be set as well so that the bus is transmitting at the desired speed.
If there are no issues when configuring the CAN controller, the next state is set to Wait for Message.
If there are any issues, the next state is set to Error.

\paragraph{}
The Wait for Message state is the state that is directly responsible for reading data off of the CAN bus.
As is described in INSERT FIGURE, if the CAN bus has a message available to be read, it reads the contents into a message variable.
If no messages are ever received, it is possible to become stuck in this state indefinately.
If there is a message received, the next state is set to Process Message.
If there are errors reading the message, the next state is set to Error.
Only one message will be read in this state, so if there are multiple messages ready to be read, the system will need to enter this state multiple times.

\paragraph{}
The Process Message state is responsible for taking the data from a received CAN message and moving it into the section of data shared by all tasks.
Additionally, in order to indicate to the storage task that a piece of data is new, an array of booleans that is equal in size to the number of data blocks exists.
When a message is received, the boolean that corresponds to the same integer value as the index of the received data block is updated to true.
This boolean will be reset to false in the storage task.
As is detailed in INSERT FIGURE, this state first checks if the CAN ID of a message is valid, something expected or able to be handled.
It then copies the contents of the CAN message into the corresponding data segment in the shared data.
Since it is expected that the CAN messages will fully correspond to the data segment and that the data segment will be byte aligned with no gaps, a simple memcpy operation can be done to move the data from the received message into the shared data.
If this processing is completed without error, the next state is set back to Wait for Message.
If there are any issues with the CAN message or the copying of the data, the next state is set to Error.

\paragraph{}
The final state of the communication task is the Error state.
This state is responsible for handling any errors that occur as a result of initialization, reading CAN messages, or processing the CAN messages.
The most common errors that can occur are the bus failing to initialize properly and an invalid or unhandled CAN message IDs are received.
The most likely cause of the CAN hardware not initializing properly are improper wiring on the PCB or invalid configuration options or settings.
In either of these scenarios, recovery is not possible and the task must be held in the Error state.
In the event of an invalid CAN ID received, the system can continue to operate sucessfully, and the task can be recovered by returning to the Wait for Message state.
In the shared data, a flag is set high indicating a fault in the communication task.

\subsection{Radio Communication Task}

\paragraph{}
The radio communication task handles the communication with the radio module and the transmission of from the vehicle to the pit area.
The Xbee module handles the over-the-air transmission of data.
The Xbee module is configured seperately, before being installed into the DAQ, accepting a UART communication line and relaying that data over the error.
The module is not configured to handle lost packets, invalid packets, or any issues related to the data transmission as dropping packets is not a catastrophic failure.

\paragraph{}
The radio communication task has five states:
\begin{itemize}
	\item Initialize
	\item Wait
	\item Build
	\item Send
	\item Error
\end{itemize}
The state machine describing how to transition between these states can be seen in \cref{fig:RadioDiagram}.
Similarly to the storage task, there is a wait state whose only function is to hold the task until a certain condition is met.
This is the only state that cannot enter the Error state.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\linewidth]{RadioStateMachine.png}
	\caption{Radio Communication State Diagram}
	\label{fig:RadioDiagram}
\end{figure}

\paragraph{}
The Initialize state is responsible for configuring the UART communication interface with the Xbee radio.
The Arduino HardwareSerial library handles configuring the registers to their alternate functions, so long as the proper tx and rx pins are set.
The baud rate is configured to by 57600 to comply with the Xbee's configuration.
If the UART initializes sucessfully, the next state is the Wait state.
If the UART communication is not initialized successfully, the next state is the Error state.

\paragraph{}
The Wait state holds the radio communication task until it is time to send a packet over-the-air.
If a one second timer has triggered, the next state is the Build state.

\paragraph{}
The Build state is responsible for creating a single packet that will then be transmitted over-the-air.
Similarly to the storage task, this state checks which data segments have been updated and adds each segment that has been updated to the packet.
The data id and the length of data are added before each data segment and a checksum is computed and added to the end of the data segment.
Differently from the storage task, each updated data segment is added to one single packet.
If the packet is created successfully, the next state is the Send state.
If there are issues creating the packet, the next state is the Error state.

\paragraph{}
The Send state writes the created packet over UART one byte at a time.

If the last byte of the packet is sent with no errors, the next state is set to the Wait state.
If there are any errors


\subsection{Sensors Task}

\subsection{Health Monitoring Task}
